# 产品需求文档：个人多模态知识库助手midas (High-Accuracy MVP)

## 1. 项目概述

开发一套 **Client-Server 架构** 的个人知识库系统。

- **服务端 (PC)**：部署在拥有 **NVIDIA RTX 4070** 显卡的电脑上，作为核心算力中心。
- **客户端 (Android)**：作为轻量级交互界面，仅用于发送指令和查看结果。
- **核心目标**：准确性优先，而非速度优先。确保音频转录精准，且小红书同步过程安全（防封号）。

## 2. 硬件与环境约束

- **服务端环境**：Python。必须利用 RTX 4070 显卡进行本地 AI 推理。
- **客户端环境**：原生 Android (Kotlin)。
- **网络环境**：局域网通讯 (HTTP)。
- **鉴权方式**：小红书鉴权采用“手动复制浏览器 Cookie”的方式，通过配置文件注入。

## 3. 服务端功能需求 (PC Side)

### 3.1 核心服务：B 站视频总结 (精度优先)

- **输入**：接收客户端发送的 B 站视频链接。
- **音频处理**：
  - 自动下载视频的高质量音频流。
- **语音转文字 (ASR)**：
  - **模型选择**：加载本地 Whisper 模型的 **Large** 版本（或显存允许范围内最大的版本），以确保最高识别准确率。
  - **推理配置**：**强制使用 GPU (CUDA) 加速**。
  - **参数要求**：配置 Beam Search 等参数以提升准确性，哪怕会增加推理时间。
- **AI 总结**：
  - 将转录后的文本发送给外部 LLM API (如 OpenAI/DeepSeek)。
  - 要求 LLM 生成结构清晰的 Markdown 笔记。

### 3.2 核心服务：小红书收藏夹同步 (风控防御版)

- **输入**：接收客户端的“同步”触发指令。
- **配置依赖**：读取本地配置中的 Cookie 和 Target Collection ID。
- **处理流程 (含反爬策略)**：
  1. **数量限制 (Limit)**：每次同步请求，**仅获取最近的 20 条**笔记，避免全量扫描触发风控。
  2. **增量去重**：维护本地数据库，对比 ID，仅处理未记录的新笔记。
  3. **随机延迟 (Jitter)**：在处理每一条新笔记之间，**必须插入 5~15 秒的随机休眠时间**，模拟人类阅读行为。
  4. **异常熔断 (Circuit Breaker)**：如果连续出现 3 次请求失败（如 461 状态码或 Cookie 失效），**立即终止当前同步任务**并写入错误日志，防止账号被进一步限制。
  5. **内容提取与总结**：提取正文文本，调用 LLM API 生成总结。
  6. **入库**：处理成功后，将 ID 写入数据库。
- **输出**：返回新增笔记的总结列表；若因熔断终止，返回特定错误提示。

### 3.3 系统配置 (`config.yaml`)

需包含：

- **Server**: Port, Host.
- **LLM**: API Key, Base URL, Model Name.
- **Whisper**: Model Path/Size (e.g., large-v3), Device (cuda).
- **Xiaohongshu**: Cookie String, Collection ID.

------

## 4. 客户端功能需求 (Android Side)

### 4.1 设置与连接

- 配置服务端的 IP 和端口。
- 提供“连接测试”按钮。

### 4.2 交互界面

- **B 站总结区**：
  - 输入框 + 提交按钮。
  - **状态反馈**：由于采用高精度模型，转录可能较慢，UI 需显示“正在高精度转录中，请耐心等待...”的加载状态。
- **小红书同步区**：
  - 单一按钮：“同步最近收藏”。
  - **状态反馈**：需显示进度（例如“正在同步：第 1/5 篇...”），并在遇到服务端熔断错误时弹出提示“Cookie 可能已失效，请检查服务端日志”。
- **结果展示区**：
  - Markdown 渲染组件（支持标题、列表、代码块）。

------

## 5. 给 AI 的开发指令 (Prompt)

**请基于以上需求，分两步生成代码。请自行选择最成熟、稳定的 Python 和 Android 库来实现。**

**第一步：后端代码 (Python)**

- 重点实现 `Anti-Scraping` (反爬) 逻辑：包括随机 Sleep、Try-Catch 熔断机制。
- 重点实现 `Whisper` 的高精度配置：代码中应显式指定使用 Large 模型和 CUDA 设备。
- 包含完整的 `requirements.txt` 和 `config.yaml` 模板。
- 包含 SQLite 数据库的初始化和操作逻辑。

**第二步：前端代码 (Android)**

- 使用 Jetpack Compose 构建 UI。
- 使用 Retrofit 处理网络请求。
- 确保耗时的网络请求在 IO 线程执行，并在 UI 上正确处理 Loading 和 Error 状态。